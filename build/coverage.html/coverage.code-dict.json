{"/home/travis/build/npmtest/node-npmtest-backbone.radio/test.js":"/* istanbul instrument in package npmtest_backbone_radio */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-backbone.radio/lib.npmtest_backbone.radio.js":"/* istanbul instrument in package npmtest_backbone_radio */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_backbone_radio = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_backbone_radio = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-backbone.radio/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-backbone.radio && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_backbone_radio */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_backbone_radio\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_backbone_radio.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_backbone_radio.rollup.js'] =\n            local.assetsDict['/assets.npmtest_backbone_radio.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_backbone_radio.__dirname + '/lib.npmtest_backbone_radio.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-backbone.radio/node_modules/backbone.radio/build/backbone.radio.js":"// Backbone.Radio v2.0.0\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('underscore'), require('backbone')) :\n  typeof define === 'function' && define.amd ? define(['underscore', 'backbone'], factory) :\n  (global.Backbone = global.Backbone || {}, global.Backbone.Radio = factory(global._,global.Backbone));\n}(this, function (_,Backbone) { 'use strict';\n\n  _ = 'default' in _ ? _['default'] : _;\n  Backbone = 'default' in Backbone ? Backbone['default'] : Backbone;\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n  };\n\n  var previousRadio = Backbone.Radio;\n\n  var Radio = Backbone.Radio = {};\n\n  Radio.VERSION = '2.0.0';\n\n  // This allows you to run multiple instances of Radio on the same\n  // webapp. After loading the new version, call `noConflict()` to\n  // get a reference to it. At the same time the old version will be\n  // returned to Backbone.Radio.\n  Radio.noConflict = function () {\n    Backbone.Radio = previousRadio;\n    return this;\n  };\n\n  // Whether or not we're in DEBUG mode or not. DEBUG mode helps you\n  // get around the issues of lack of warnings when events are mis-typed.\n  Radio.DEBUG = false;\n\n  // Format debug text.\n  Radio._debugText = function (warning, eventName, channelName) {\n    return warning + (channelName ? ' on the ' + channelName + ' channel' : '') + ': \"' + eventName + '\"';\n  };\n\n  // This is the method that's called when an unregistered event was called.\n  // By default, it logs warning to the console. By overriding this you could\n  // make it throw an Error, for instance. This would make firing a nonexistent event\n  // have the same consequence as firing a nonexistent method on an Object.\n  Radio.debugLog = function (warning, eventName, channelName) {\n    if (Radio.DEBUG && console && console.warn) {\n      console.warn(Radio._debugText(warning, eventName, channelName));\n    }\n  };\n\n  var eventSplitter = /\\s+/;\n\n  // An internal method used to handle Radio's method overloading for Requests.\n  // It's borrowed from Backbone.Events. It differs from Backbone's overload\n  // API (which is used in Backbone.Events) in that it doesn't support space-separated\n  // event names.\n  Radio._eventsApi = function (obj, action, name, rest) {\n    if (!name) {\n      return false;\n    }\n\n    var results = {};\n\n    // Handle event maps.\n    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      for (var key in name) {\n        var result = obj[action].apply(obj, [key, name[key]].concat(rest));\n        eventSplitter.test(key) ? _.extend(results, result) : results[key] = result;\n      }\n      return results;\n    }\n\n    // Handle space separated event names.\n    if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n      for (var i = 0, l = names.length; i < l; i++) {\n        results[names[i]] = obj[action].apply(obj, [names[i]].concat(rest));\n      }\n      return results;\n    }\n\n    return false;\n  };\n\n  // An optimized way to execute callbacks.\n  Radio._callHandler = function (callback, context, args) {\n    var a1 = args[0],\n        a2 = args[1],\n        a3 = args[2];\n    switch (args.length) {\n      case 0:\n        return callback.call(context);\n      case 1:\n        return callback.call(context, a1);\n      case 2:\n        return callback.call(context, a1, a2);\n      case 3:\n        return callback.call(context, a1, a2, a3);\n      default:\n        return callback.apply(context, args);\n    }\n  };\n\n  // A helper used by `off` methods to the handler from the store\n  function removeHandler(store, name, callback, context) {\n    var event = store[name];\n    if ((!callback || callback === event.callback || callback === event.callback._callback) && (!context || context === event.context)) {\n      delete store[name];\n      return true;\n    }\n  }\n\n  function removeHandlers(store, name, callback, context) {\n    store || (store = {});\n    var names = name ? [name] : _.keys(store);\n    var matched = false;\n\n    for (var i = 0, length = names.length; i < length; i++) {\n      name = names[i];\n\n      // If there's no event by this name, log it and continue\n      // with the loop\n      if (!store[name]) {\n        continue;\n      }\n\n      if (removeHandler(store, name, callback, context)) {\n        matched = true;\n      }\n    }\n\n    return matched;\n  }\n\n  /*\n   * tune-in\n   * -------\n   * Get console logs of a channel's activity\n   *\n   */\n\n  var _logs = {};\n\n  // This is to produce an identical function in both tuneIn and tuneOut,\n  // so that Backbone.Events unregisters it.\n  function _partial(channelName) {\n    return _logs[channelName] || (_logs[channelName] = _.bind(Radio.log, Radio, channelName));\n  }\n\n  _.extend(Radio, {\n\n    // Log information about the channel and event\n    log: function log(channelName, eventName) {\n      if (typeof console === 'undefined') {\n        return;\n      }\n      var args = _.toArray(arguments).slice(2);\n      console.log('[' + channelName + '] \"' + eventName + '\"', args);\n    },\n\n    // Logs all events on this channel to the console. It sets an\n    // internal value on the channel telling it we're listening,\n    // then sets a listener on the Backbone.Events\n    tuneIn: function tuneIn(channelName) {\n      var channel = Radio.channel(channelName);\n      channel._tunedIn = true;\n      channel.on('all', _partial(channelName));\n      return this;\n    },\n\n    // Stop logging all of the activities on this channel to the console\n    tuneOut: function tuneOut(channelName) {\n      var channel = Radio.channel(channelName);\n      channel._tunedIn = false;\n      channel.off('all', _partial(channelName));\n      delete _logs[channelName];\n      return this;\n    }\n  });\n\n  /*\n   * Backbone.Radio.Requests\n   * -----------------------\n   * A messaging system for requesting data.\n   *\n   */\n\n  function makeCallback(callback) {\n    return _.isFunction(callback) ? callback : function () {\n      return callback;\n    };\n  }\n\n  Radio.Requests = {\n\n    // Make a request\n    request: function request(name) {\n      var args = _.toArray(arguments).slice(1);\n      var results = Radio._eventsApi(this, 'request', name, args);\n      if (results) {\n        return results;\n      }\n      var channelName = this.channelName;\n      var requests = this._requests;\n\n      // Check if we should log the request, and if so, do it\n      if (channelName && this._tunedIn) {\n        Radio.log.apply(this, [channelName, name].concat(args));\n      }\n\n      // If the request isn't handled, log it in DEBUG mode and exit\n      if (requests && (requests[name] || requests['default'])) {\n        var handler = requests[name] || requests['default'];\n        args = requests[name] ? args : arguments;\n        return Radio._callHandler(handler.callback, handler.context, args);\n      } else {\n        Radio.debugLog('An unhandled request was fired', name, channelName);\n      }\n    },\n\n    // Set up a handler for a request\n    reply: function reply(name, callback, context) {\n      if (Radio._eventsApi(this, 'reply', name, [callback, context])) {\n        return this;\n      }\n\n      this._requests || (this._requests = {});\n\n      if (this._requests[name]) {\n        Radio.debugLog('A request was overwritten', name, this.channelName);\n      }\n\n      this._requests[name] = {\n        callback: makeCallback(callback),\n        context: context || this\n      };\n\n      return this;\n    },\n\n    // Set up a handler that can only be requested once\n    replyOnce: function replyOnce(name, callback, context) {\n      if (Radio._eventsApi(this, 'replyOnce', name, [callback, context])) {\n        return this;\n      }\n\n      var self = this;\n\n      var once = _.once(function () {\n        self.stopReplying(name);\n        return makeCallback(callback).apply(this, arguments);\n      });\n\n      return this.reply(name, once, context);\n    },\n\n    // Remove handler(s)\n    stopReplying: function stopReplying(name, callback, context) {\n      if (Radio._eventsApi(this, 'stopReplying', name)) {\n        return this;\n      }\n\n      // Remove everything if there are no arguments passed\n      if (!name && !callback && !context) {\n        delete this._requests;\n      } else if (!removeHandlers(this._requests, name, callback, context)) {\n        Radio.debugLog('Attempted to remove the unregistered request', name, this.channelName);\n      }\n\n      return this;\n    }\n  };\n\n  /*\n   * Backbone.Radio.channel\n   * ----------------------\n   * Get a reference to a channel by name.\n   *\n   */\n\n  Radio._channels = {};\n\n  Radio.channel = function (channelName) {\n    if (!channelName) {\n      throw new Error('You must provide a name for the channel.');\n    }\n\n    if (Radio._channels[channelName]) {\n      return Radio._channels[channelName];\n    } else {\n      return Radio._channels[channelName] = new Radio.Channel(channelName);\n    }\n  };\n\n  /*\n   * Backbone.Radio.Channel\n   * ----------------------\n   * A Channel is an object that extends from Backbone.Events,\n   * and Radio.Requests.\n   *\n   */\n\n  Radio.Channel = function (channelName) {\n    this.channelName = channelName;\n  };\n\n  _.extend(Radio.Channel.prototype, Backbone.Events, Radio.Requests, {\n\n    // Remove all handlers from the messaging systems of this channel\n    reset: function reset() {\n      this.off();\n      this.stopListening();\n      this.stopReplying();\n      return this;\n    }\n  });\n\n  /*\n   * Top-level API\n   * -------------\n   * Supplies the 'top-level API' for working with Channels directly\n   * from Backbone.Radio.\n   *\n   */\n\n  var channel;\n  var args;\n  var systems = [Backbone.Events, Radio.Requests];\n  _.each(systems, function (system) {\n    _.each(system, function (method, methodName) {\n      Radio[methodName] = function (channelName) {\n        args = _.toArray(arguments).slice(1);\n        channel = this.channel(channelName);\n        return channel[methodName].apply(channel, args);\n      };\n    });\n  });\n\n  Radio.reset = function (channelName) {\n    var channels = !channelName ? this._channels : [this._channels[channelName]];\n    _.each(channels, function (channel) {\n      channel.reset();\n    });\n  };\n\n  return Radio;\n\n}));\n//# sourceMappingURL=./backbone.radio.js.map","/home/travis/build/npmtest/node-npmtest-backbone.radio/node_modules/backbone.radio/gulpfile.babel.js":"import gulp  from 'gulp';\nimport loadPlugins from 'gulp-load-plugins';\nimport del  from 'del';\nimport glob  from 'glob';\nimport path  from 'path';\nimport {Instrumenter} from 'isparta';\nimport webpack from 'webpack';\nimport webpackStream from 'webpack-stream';\n\nimport _ from 'underscore';\nimport rollup from 'rollup';\nimport babel from 'rollup-plugin-babel';\nimport preset from 'babel-preset-es2015-rollup';\nimport fs from 'fs';\nimport mkdirp from 'mkdirp';\n\nimport mochaGlobals from './test/setup/.globals';\nimport manifest  from './package.json';\n\n// Load all of our Gulp plugins\nconst $ = loadPlugins();\n\n// Gather the library data from `package.json`\nconst config = manifest.babelBoilerplateOptions;\nconst mainFile = manifest.main;\nconst destinationFolder = path.dirname(mainFile);\nconst exportFileName = path.basename(mainFile, path.extname(mainFile));\n\nfunction cleanDist(done) {\n  del([destinationFolder]).then(() => done());\n}\n\nfunction cleanTmp(done) {\n  del(['tmp']).then(() => done());\n}\n\nfunction onError() {\n  $.util.beep();\n}\n\n// Lint a set of files\nfunction lint(files) {\n  return gulp.src(files)\n    .pipe($.plumber())\n    .pipe($.eslint())\n    .pipe($.eslint.format())\n    .pipe($.eslint.failOnError())\n    .pipe($.jscs())\n    .pipe($.jscs.reporter())\n    .pipe($.jscs.reporter('fail'))\n    .on('error', onError);\n}\n\nfunction lintSrc() {\n  return lint('src/**/*.js');\n}\n\nfunction lintTest() {\n  return lint('test/**/*.js');\n}\n\nfunction lintGulpfile() {\n  return lint('gulpfile.babel.js');\n}\n\nfunction getBanner() {\n  var banner = '// Backbone.Radio v<%= version %>\\n';\n  return _.template(banner)(manifest);\n}\n\nfunction build(done) {\n  rollup.rollup({\n    entry: path.join('src', config.entryFileName),\n    plugins: [\n      babel({\n        sourceMaps: true,\n        presets: [preset],\n        babelrc: false\n      })\n    ]\n  }).then(function(bundle) {\n    var banner = getBanner();\n\n    var result = bundle.generate({\n      banner: banner,\n      format: 'umd',\n      sourceMap: 'inline',\n      sourceMapSource: config.entryFileName + '.js',\n      sourceMapFile: exportFileName + '.js',\n      moduleName: config.mainVarName\n    });\n    var code = _.template(result.code.toString())(manifest) +\n          `\\n//# sourceMappingURL=./${exportFileName}.js.map`;\n\n    // Write the generated sourcemap\n    mkdirp.sync(destinationFolder);\n    fs.writeFileSync(path.join(destinationFolder, exportFileName + '.js'), code);\n    fs.writeFileSync(path.join(destinationFolder, `${exportFileName}.js.map`), result.map.toString());\n\n    $.file(exportFileName + '.js', code, { src: true })\n      .pipe($.plumber())\n      .pipe($.sourcemaps.init({ loadMaps: true }))\n      .pipe($.sourcemaps.write('./', {addComment: false}))\n      .pipe(gulp.dest(destinationFolder))\n      .pipe($.filter(['*', '!**/*.js.map']))\n      .pipe($.rename(exportFileName + '.min.js'))\n      .pipe($.sourcemaps.init({ loadMaps: true }))\n      .pipe($.uglify())\n      .pipe($.header(banner))\n      .pipe($.sourcemaps.write('./'))\n      .pipe(gulp.dest(destinationFolder))\n      .on('end', done);\n  }).catch(console.error);\n}\n\nfunction _mocha() {\n  return gulp.src(['test/setup/node.js', 'test/unit/**/*.js'], {read: false})\n    .pipe($.mocha({\n      reporter: 'dot',\n      globals: Object.keys(mochaGlobals.globals),\n      ignoreLeaks: false\n    }));\n}\n\nfunction _registerBabel() {\n  require('babel-register');\n}\n\nfunction test() {\n  _registerBabel();\n  return _mocha();\n}\n\nfunction coverage(done) {\n  _registerBabel();\n  gulp.src(['src/**/*.js'])\n    .pipe($.istanbul({ instrumenter: Instrumenter }))\n    .pipe($.istanbul.hookRequire())\n    .on('finish', () => {\n      return test()\n        .pipe($.istanbul.writeReports())\n        .on('end', done);\n    });\n}\n\nconst watchFiles = ['src/**/*', 'test/**/*', 'package.json', '**/.eslintrc', '.jscsrc'];\n\n// Run the headless unit tests as you make changes.\nfunction watch() {\n  gulp.watch(watchFiles, ['test']);\n}\n\nfunction testBrowser() {\n  // Our testing bundle is made up of our unit tests, which\n  // should individually load up pieces of our application.\n  // We also include the browser setup file.\n  const testFiles = glob.sync('./test/unit/**/*.js');\n  const allFiles = ['./test/setup/browser.js'].concat(testFiles);\n\n  // Lets us differentiate between the first build and subsequent builds\n  var firstBuild = true;\n\n  // This empty stream might seem like a hack, but we need to specify all of our files through\n  // the `entry` option of webpack. Otherwise, it ignores whatever file(s) are placed in here.\n  return gulp.src('')\n    .pipe($.plumber())\n    .pipe(webpackStream({\n      watch: true,\n      entry: allFiles,\n      output: {\n        filename: '__spec-build.js'\n      },\n      module: {\n        loaders: [\n          // This is what allows us to author in future JavaScript\n          { test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader' },\n          // This allows the test setup scripts to load `package.json`\n          { test: /\\.json$/, exclude: /node_modules/, loader: 'json-loader' }\n        ]\n      },\n      plugins: [\n        // By default, webpack does `n=>n` compilation with entry files. This concatenates\n        // them into a single chunk.\n        new webpack.optimize.LimitChunkCountPlugin({ maxChunks: 1 })\n      ],\n      devtool: 'inline-source-map'\n    }, null, function() {\n      if (firstBuild) {\n        $.livereload.listen({port: 35729, host: 'localhost', start: true});\n        var watcher = gulp.watch(watchFiles, ['lint']);\n      } else {\n        $.livereload.reload('./tmp/__spec-build.js');\n      }\n      firstBuild = false;\n    }))\n    .pipe(gulp.dest('./tmp'));\n}\n\n// Remove the built files\ngulp.task('clean', cleanDist);\n\n// Remove our temporary files\ngulp.task('clean-tmp', cleanTmp);\n\n// Lint our source code\ngulp.task('lint-src', lintSrc);\n\n// Lint our test code\ngulp.task('lint-test', lintTest);\n\n// Lint this file\ngulp.task('lint-gulpfile', lintGulpfile);\n\n// Lint everything\ngulp.task('lint', ['lint-src', 'lint-test', 'lint-gulpfile']);\n\n// Build two versions of the library\ngulp.task('build', ['lint', 'clean'], build);\n\n// Lint and run our tests\ngulp.task('test', ['lint'], test);\n\n// Set up coverage and run tests\ngulp.task('coverage', ['lint'], coverage);\n\n// Set up a livereload environment for our spec runner `test/runner.html`\ngulp.task('test-browser', ['lint', 'clean-tmp'], testBrowser);\n\n// Run the headless unit tests as you make changes.\ngulp.task('watch', watch);\n\n// An alias of test\ngulp.task('default', ['test']);\n","/home/travis/build/npmtest/node-npmtest-backbone.radio/node_modules/backbone.radio/src/backbone.radio.js":"import _ from 'underscore';\nimport Backbone from 'backbone';\n\nvar previousRadio = Backbone.Radio;\n\nvar Radio = Backbone.Radio = {};\n\nRadio.VERSION = '<%= version %>';\n\n// This allows you to run multiple instances of Radio on the same\n// webapp. After loading the new version, call `noConflict()` to\n// get a reference to it. At the same time the old version will be\n// returned to Backbone.Radio.\nRadio.noConflict = function() {\n  Backbone.Radio = previousRadio;\n  return this;\n};\n\n// Whether or not we're in DEBUG mode or not. DEBUG mode helps you\n// get around the issues of lack of warnings when events are mis-typed.\nRadio.DEBUG = false;\n\n// Format debug text.\nRadio._debugText = function(warning, eventName, channelName) {\n  return warning + (channelName ? ' on the ' + channelName + ' channel' : '') +\n    ': \"' + eventName + '\"';\n};\n\n// This is the method that's called when an unregistered event was called.\n// By default, it logs warning to the console. By overriding this you could\n// make it throw an Error, for instance. This would make firing a nonexistent event\n// have the same consequence as firing a nonexistent method on an Object.\nRadio.debugLog = function(warning, eventName, channelName) {\n  if (Radio.DEBUG && console && console.warn) {\n    console.warn(Radio._debugText(warning, eventName, channelName));\n  }\n};\n\nvar eventSplitter = /\\s+/;\n\n// An internal method used to handle Radio's method overloading for Requests.\n// It's borrowed from Backbone.Events. It differs from Backbone's overload\n// API (which is used in Backbone.Events) in that it doesn't support space-separated\n// event names.\nRadio._eventsApi = function(obj, action, name, rest) {\n  if (!name) {\n    return false;\n  }\n\n  var results = {};\n\n  // Handle event maps.\n  if (typeof name === 'object') {\n    for (var key in name) {\n      var result = obj[action].apply(obj, [key, name[key]].concat(rest));\n      eventSplitter.test(key) ? _.extend(results, result) : results[key] = result;\n    }\n    return results;\n  }\n\n  // Handle space separated event names.\n  if (eventSplitter.test(name)) {\n    var names = name.split(eventSplitter);\n    for (var i = 0, l = names.length; i < l; i++) {\n      results[names[i]] = obj[action].apply(obj, [names[i]].concat(rest));\n    }\n    return results;\n  }\n\n  return false;\n};\n\n// An optimized way to execute callbacks.\nRadio._callHandler = function(callback, context, args) {\n  var a1 = args[0], a2 = args[1], a3 = args[2];\n  switch (args.length) {\n    case 0: return callback.call(context);\n    case 1: return callback.call(context, a1);\n    case 2: return callback.call(context, a1, a2);\n    case 3: return callback.call(context, a1, a2, a3);\n    default: return callback.apply(context, args);\n  }\n};\n\n// A helper used by `off` methods to the handler from the store\nfunction removeHandler(store, name, callback, context) {\n  var event = store[name];\n  if (\n     (!callback || (callback === event.callback || callback === event.callback._callback)) &&\n     (!context || (context === event.context))\n  ) {\n    delete store[name];\n    return true;\n  }\n}\n\nfunction removeHandlers(store, name, callback, context) {\n  store || (store = {});\n  var names = name ? [name] : _.keys(store);\n  var matched = false;\n\n  for (var i = 0, length = names.length; i < length; i++) {\n    name = names[i];\n\n    // If there's no event by this name, log it and continue\n    // with the loop\n    if (!store[name]) {\n      continue;\n    }\n\n    if (removeHandler(store, name, callback, context)) {\n      matched = true;\n    }\n  }\n\n  return matched;\n}\n\n/*\n * tune-in\n * -------\n * Get console logs of a channel's activity\n *\n */\n\nvar _logs = {};\n\n// This is to produce an identical function in both tuneIn and tuneOut,\n// so that Backbone.Events unregisters it.\nfunction _partial(channelName) {\n  return _logs[channelName] || (_logs[channelName] = _.bind(Radio.log, Radio, channelName));\n}\n\n_.extend(Radio, {\n\n  // Log information about the channel and event\n  log: function(channelName, eventName) {\n    if (typeof console === 'undefined') { return; }\n    var args = _.toArray(arguments).slice(2);\n    console.log('[' + channelName + '] \"' + eventName + '\"', args);\n  },\n\n  // Logs all events on this channel to the console. It sets an\n  // internal value on the channel telling it we're listening,\n  // then sets a listener on the Backbone.Events\n  tuneIn: function(channelName) {\n    var channel = Radio.channel(channelName);\n    channel._tunedIn = true;\n    channel.on('all', _partial(channelName));\n    return this;\n  },\n\n  // Stop logging all of the activities on this channel to the console\n  tuneOut: function(channelName) {\n    var channel = Radio.channel(channelName);\n    channel._tunedIn = false;\n    channel.off('all', _partial(channelName));\n    delete _logs[channelName];\n    return this;\n  }\n});\n\n/*\n * Backbone.Radio.Requests\n * -----------------------\n * A messaging system for requesting data.\n *\n */\n\nfunction makeCallback(callback) {\n  return _.isFunction(callback) ? callback : function() { return callback; };\n}\n\nRadio.Requests = {\n\n  // Make a request\n  request: function(name) {\n    var args = _.toArray(arguments).slice(1);\n    var results = Radio._eventsApi(this, 'request', name, args);\n    if (results) {\n      return results;\n    }\n    var channelName = this.channelName;\n    var requests = this._requests;\n\n    // Check if we should log the request, and if so, do it\n    if (channelName && this._tunedIn) {\n      Radio.log.apply(this, [channelName, name].concat(args));\n    }\n\n    // If the request isn't handled, log it in DEBUG mode and exit\n    if (requests && (requests[name] || requests['default'])) {\n      var handler = requests[name] || requests['default'];\n      args = requests[name] ? args : arguments;\n      return Radio._callHandler(handler.callback, handler.context, args);\n    } else {\n      Radio.debugLog('An unhandled request was fired', name, channelName);\n    }\n  },\n\n  // Set up a handler for a request\n  reply: function(name, callback, context) {\n    if (Radio._eventsApi(this, 'reply', name, [callback, context])) {\n      return this;\n    }\n\n    this._requests || (this._requests = {});\n\n    if (this._requests[name]) {\n      Radio.debugLog('A request was overwritten', name, this.channelName);\n    }\n\n    this._requests[name] = {\n      callback: makeCallback(callback),\n      context: context || this\n    };\n\n    return this;\n  },\n\n  // Set up a handler that can only be requested once\n  replyOnce: function(name, callback, context) {\n    if (Radio._eventsApi(this, 'replyOnce', name, [callback, context])) {\n      return this;\n    }\n\n    var self = this;\n\n    var once = _.once(function() {\n      self.stopReplying(name);\n      return makeCallback(callback).apply(this, arguments);\n    });\n\n    return this.reply(name, once, context);\n  },\n\n  // Remove handler(s)\n  stopReplying: function(name, callback, context) {\n    if (Radio._eventsApi(this, 'stopReplying', name)) {\n      return this;\n    }\n\n    // Remove everything if there are no arguments passed\n    if (!name && !callback && !context) {\n      delete this._requests;\n    } else if (!removeHandlers(this._requests, name, callback, context)) {\n      Radio.debugLog('Attempted to remove the unregistered request', name, this.channelName);\n    }\n\n    return this;\n  }\n};\n\n/*\n * Backbone.Radio.channel\n * ----------------------\n * Get a reference to a channel by name.\n *\n */\n\nRadio._channels = {};\n\nRadio.channel = function(channelName) {\n  if (!channelName) {\n    throw new Error('You must provide a name for the channel.');\n  }\n\n  if (Radio._channels[channelName]) {\n    return Radio._channels[channelName];\n  } else {\n    return (Radio._channels[channelName] = new Radio.Channel(channelName));\n  }\n};\n\n/*\n * Backbone.Radio.Channel\n * ----------------------\n * A Channel is an object that extends from Backbone.Events,\n * and Radio.Requests.\n *\n */\n\nRadio.Channel = function(channelName) {\n  this.channelName = channelName;\n};\n\n_.extend(Radio.Channel.prototype, Backbone.Events, Radio.Requests, {\n\n  // Remove all handlers from the messaging systems of this channel\n  reset: function() {\n    this.off();\n    this.stopListening();\n    this.stopReplying();\n    return this;\n  }\n});\n\n/*\n * Top-level API\n * -------------\n * Supplies the 'top-level API' for working with Channels directly\n * from Backbone.Radio.\n *\n */\n\nvar channel, args, systems = [Backbone.Events, Radio.Requests];\n\n_.each(systems, function(system) {\n  _.each(system, function(method, methodName) {\n    Radio[methodName] = function(channelName) {\n      args = _.toArray(arguments).slice(1);\n      channel = this.channel(channelName);\n      return channel[methodName].apply(channel, args);\n    };\n  });\n});\n\nRadio.reset = function(channelName) {\n  var channels = !channelName ? this._channels : [this._channels[channelName]];\n  _.each(channels, function(channel) { channel.reset();});\n};\n\nexport default Radio;\n"}